**1、在动态分配堆上内存的时候，析构函数必须是虚函数**

**原因：**动态分配堆上内存，无法自动回收。若基类指针指向派生类，然后基类指针调用`delete`方法，只能释放基类的内存，无法释放派生类特有的部分内存，进而导致内存泄露。

析构函数定义成虚函数，基类指针调用`delete`方法，会先调用派生类的析构函数，然后自动调用基类的析构函数。

析构函数必须是定义虚函数，但没有必要是纯虚的。

**2、友元不支持虚拟函数**

因为友元函数不是成员函数，只有成员函数才可以是虚函数。

另一个方面，虚函数的目的是通过基类对象访问派生类实现的函数，友元函数不是不是成员函数，更无继承关系。

**3、虚函数必须要在基类实现，不实现，编译会报错**

规定。

纯虚函数必须不能实现。

**4、虚函数是C++实现多态的机制**

C++多态指的是调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。

而我们在基类定义了虚函数，并在派生类实现了虚函数，通过基类对象指针却可以指向派生类的实现的成员函数。

因此虚函数是C++实现多态的机制。

**5、为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数？**

将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

**6、静态函数和虚函数的区别**

静态函数在编译期就确定了运行，而虚函数在运行期动态绑定，动态绑定的依据是虚函数指针和虚函数表。

因为额为增加虚函数指针和虚函数表，所以会带来额外的内存开销。

**7、多态和虚函数**

多态分为静态多态和动态多态。

- 静态多态主要是重载，在编译的时候就已经确定；
- 动态多态是用虚函数机制实现的，在运行期间动态绑定。

**8、C++类的构造函数不能为虚函数**

- 解释一：

  ```cpp
  C++类的对象构造的时候，首先申请一片内存，然后调用构造函数进行初始化；
  我们知道，存在虚函数的话，也会存在一个虚函数表vtable，而虚函数表示在什么时候产生的呢，当然是在调用构造函数之后产生的；
  那么问题来了，如果构造函数为虚函数，此时的内存是一片空白，不存在该虚函数表vtable，那么无法找到该构造函数；
  所以说，构造函数不能为虚函数。
  ————————————————
  原文链接：https://blog.csdn.net/zjccsg/article/details/51926087
  ```

- 解释二：

  ```cpp
  1、虚函数相应一个指向vtable虚函数表的指针，但是这个指向vtable的指针事实上是存储在对象的内存空间的。假设构造函数是虚的，就须要通过 vtable来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数。
  
  2、虚函数的作用在于通过子类的指针或引用来调用父类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过子类的指针或者引用去调用。
  ————————————————
  原文链接：https://blog.csdn.net/qq_44132777/article/details/114896753
  ```

  